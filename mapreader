import org.apache.poi.ss.usermodel.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.StreamSupport;
import com.typesafe.config.*;

public class DynamicConfigBuilder {

    public static Map<String, Object> buildDynamicConfig(String excelPath) throws Exception {
        var rootMap = new HashMap<String, Object>();

        // Read data from Excel and build the nested config structure
        Map<String, Object> scenariosMap = readScenariosFromExcel(excelPath);

        // Construct the hierarchy based on the corrected structure
        Map<String, Object> valueMap = new HashMap<>();
        valueMap.put("value", scenariosMap);

        Map<String, Object> definitionsMap = new HashMap<>();
        definitionsMap.put("definitions", valueMap);

        Map<String, Object> testMap = new HashMap<>();
        testMap.put("test", definitionsMap);

        rootMap.put("object", testMap);

        return rootMap;
    }

    private static Map<String, Object> readScenariosFromExcel(String excelPath) throws Exception {
        var scenariosMap = new HashMap<String, Object>();

        // Try-with-resources ensures the input stream is closed automatically
        try (var fis = Files.newInputStream(Path.of(excelPath));
             Workbook workbook = WorkbookFactory.create(fis)) {

            Sheet sheet = workbook.getSheetAt(0);

            StreamSupport.stream(sheet.spliterator(), false).forEach(row -> {
                Cell scenarioCell = row.getCell(0); // Scenario name (e.g., "getP2PByUUID")
                Cell tpsCell = row.getCell(1);      // TPS value

                assert scenarioCell != null && tpsCell != null : "Required cells are null in row " + row.getRowNum();

                String scenarioName = scenarioCell.getStringCellValue();
                double tpsValue = tpsCell.getNumericCellValue();

                Map<String, Object> tpsMap = new HashMap<>();
                tpsMap.put("tps", tpsValue);

                Map<String, Object> valueMap = new HashMap<>();
                valueMap.put("value", tpsMap);

                scenariosMap.put(scenarioName, valueMap);
            });
        }

        return scenariosMap;
    }

    public static void main(String[] args) {
        try {
            String excelPath = "path/to/your/excel.xlsx";
            Map<String, Object> dynamicConfigMap = buildDynamicConfig(excelPath);

            // Print the dynamically built map
            System.out.println(dynamicConfigMap);

            // Convert to Lightbend Config
            Config config = ConfigFactory.parseMap(dynamicConfigMap);
            System.out.println(config.root().render());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

record TPSData(double defaultTps, double prodTps, double prodWeight, double deltaTps, double deltaWeight) {}

class BusinessLogic {
    public static double calculateFinalTps(TPSData tpsData) {
        // Business logic for calculating final TPS
        return (tpsData.prodTps() * tpsData.prodWeight() + 
                tpsData.deltaTps() * tpsData.deltaWeight() + 
                tpsData.defaultTps()) / 
               (tpsData.prodWeight() + tpsData.deltaWeight() + 1);
    }
}

--------



def replace_placeholders_in_file(conf_file_path, definitions):
    # Read file as raw text lines
    with open(conf_file_path, 'r') as f:
        lines = f.readlines()

    modified_lines = []
    for line in lines:
        # For each key in definitions
        replaced_line = line
        for key, config_items in definitions.items():
            for item in config_items:
                if f"{item} =" in line:  # a simplistic detection
                    placeholder = f"${{{item.upper()}}}"
                    # Replace the right-hand side only, preserving spacing
                    # Example assumption: "  tps = 10"
                    # If you need more robust parsing, you might use a regex.
                    replaced_line = re.sub(
                        r'(\s*' + item + r'\s*=\s*).*',
                        r'\1' + placeholder,
                        line
                    )
                    break
            line = replaced_line
        modified_lines.append(replaced_line)
    
    # Write back to file if changes occurred
    with open(conf_file_path, 'w') as f:
        f.writelines(modified_lines)
