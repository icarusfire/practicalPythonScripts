import org.apache.poi.ss.usermodel.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.StreamSupport;
import com.typesafe.config.*;

public class DynamicConfigBuilder {

    public static Map<String, Object> buildDynamicConfig(String excelPath) throws Exception {
        var rootMap = new HashMap<String, Object>();

        // Read data from Excel and build the nested config structure
        Map<String, Object> scenariosMap = readScenariosFromExcel(excelPath);

        // Construct the hierarchy based on the corrected structure
        Map<String, Object> valueMap = new HashMap<>();
        valueMap.put("value", scenariosMap);

        Map<String, Object> definitionsMap = new HashMap<>();
        definitionsMap.put("definitions", valueMap);

        Map<String, Object> testMap = new HashMap<>();
        testMap.put("test", definitionsMap);

        rootMap.put("object", testMap);

        return rootMap;
    }

    private static Map<String, Object> readScenariosFromExcel(String excelPath) throws Exception {
        var scenariosMap = new HashMap<String, Object>();

        // Try-with-resources ensures the input stream is closed automatically
        try (var fis = Files.newInputStream(Path.of(excelPath));
             Workbook workbook = WorkbookFactory.create(fis)) {

            Sheet sheet = workbook.getSheetAt(0);

            StreamSupport.stream(sheet.spliterator(), false).forEach(row -> {
                Cell scenarioCell = row.getCell(0); // Scenario name (e.g., "getP2PByUUID")
                Cell tpsCell = row.getCell(1);      // TPS value

                assert scenarioCell != null && tpsCell != null : "Required cells are null in row " + row.getRowNum();

                String scenarioName = scenarioCell.getStringCellValue();
                double tpsValue = tpsCell.getNumericCellValue();

                Map<String, Object> tpsMap = new HashMap<>();
                tpsMap.put("tps", tpsValue);

                Map<String, Object> valueMap = new HashMap<>();
                valueMap.put("value", tpsMap);

                scenariosMap.put(scenarioName, valueMap);
            });
        }

        return scenariosMap;
    }

    public static void main(String[] args) {
        try {
            String excelPath = "path/to/your/excel.xlsx";
            Map<String, Object> dynamicConfigMap = buildDynamicConfig(excelPath);

            // Print the dynamically built map
            System.out.println(dynamicConfigMap);

            // Convert to Lightbend Config
            Config config = ConfigFactory.parseMap(dynamicConfigMap);
            System.out.println(config.root().render());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

record TPSData(double defaultTps, double prodTps, double prodWeight, double deltaTps, double deltaWeight) {}

class BusinessLogic {
    public static double calculateFinalTps(TPSData tpsData) {
        // Business logic for calculating final TPS
        return (tpsData.prodTps() * tpsData.prodWeight() + 
                tpsData.deltaTps() * tpsData.deltaWeight() + 
                tpsData.defaultTps()) / 
               (tpsData.prodWeight() + tpsData.deltaWeight() + 1);
    }
}

-------- replace reader---
import re
import tempfile
import os

def replace_placeholders_in_conf(conf_file_path, scenarios, arr):
    """
    Replaces values in lines where:
    test.definitions.<key>.<item> = <value>
    with:
    test.definitions.<key>.<item> = ${<ITEM_UPPER>}

    Keeps other lines and formatting untouched.
    """

    with open(conf_file_path, 'r') as f:
        lines = f.readlines()

    modified = False

    # For each scenario key
    for key, config_item in scenarios.items():
        # For each item in arr we want to replace
        for item in arr:
            if item in config_item:
                # Build a regex that matches lines in the format:
                # test.definitions.<key>.<item> = ...
                pattern = (
                    r'^(\s*test\.definitions\.' 
                    + re.escape(key) 
                    + r'\.' 
                    + re.escape(item) 
                    + r'\s*=\s*)(.*)$'
                )

                updated_lines = []
                for line in lines:
                    new_line = re.sub(pattern, r'\1${' + item.upper() + '}', line)
                    if new_line != line:
                        modified = True
                    updated_lines.append(new_line)

                # Update lines for next iteration
                lines = updated_lines

    if modified:
        with open(conf_file_path, 'w') as f:
            f.writelines(lines)


# ---------------------
# Basic Test Example
# ---------------------
if __name__ == "__main__":

    # Example .conf content
    original_conf_content = """\
# Some comment line
test.definitions.scenarioA.timeout = 300
test.definitions.scenarioA.retries = 5
test.definitions.scenarioB.timeout = 600
some_other_field = [1,2]
"""

    # Create a temporary file to simulate a real .conf
    with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix=".conf") as tmp_file:
        tmp_file_path = tmp_file.name
        tmp_file.write(original_conf_content)

    # Example scenarios dictionary to replace
    # Key "scenarioA" has items "timeout" in its list
    # Key "scenarioB" does not match items we look for in arr
    scenarios = {
        "scenarioA": ["timeout", "foo"],
        "scenarioB": ["bar"]
    }

    # We only want to replace "timeout" items in scenarioA
    arr = ["timeout"]

    # Replace placeholders
    replace_placeholders_in_conf(tmp_file_path, scenarios, arr)

    # Read the file back and print to confirm changes
    with open(tmp_file_path, 'r') as f:
        updated_content = f.read()
        print("Updated .conf content:")
        print(updated_content)

    # Clean up the temp file
    os.remove(tmp_file_path)


---------

