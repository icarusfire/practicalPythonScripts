import os
import re
import hashlib
import csv
from pathlib import Path
from configparser import ConfigParser

# Fields to be replaced with placeholder
fields_to_be_replaced_with_placeholder = ["tps"]

def short_hash(hash_input, length=5):
    """Generate a short hash using SHA-256."""
    full_hash = hashlib.sha256(hash_input.encode()).hexdigest()
    return full_hash[:length]

def replace_values_with_placeholders(conf_file_path, scenarios):
    """Replaces values of specified fields with placeholders in a config file."""
    with open(conf_file_path, "r") as f:
        lines = f.readlines()

    modified_lines = []
    for line in lines:
        replaced_line = line
        for key, config_items in scenarios.items():
            for item in config_items:
                if item in fields_to_be_replaced_with_placeholder and f'"{item}" =' in line:
                    placeholder = f'"${{{item}}}"'
                    replaced_line = re.sub(rf'("{item}" = )(".*?")', rf'\1{placeholder}', line)
                    break
            line = replaced_line
        modified_lines.append(replaced_line)

    with open(conf_file_path, "w") as f:
        f.writelines(modified_lines)

def process_definitions(scenarios, conf_file, csv_writer):
    """Processes config definitions and extracts relevant values."""
    for scenario_name, scenario_definition in scenarios.items():
        print(
            conf_file.parent.name, conf_file.name, scenario_name,
            scenario_definition.get("weight", 1),
            scenario_definition.get("tps", 0)
        )
        csv_writer.writerow([
            conf_file.parent.name,
            conf_file.name,
            scenario_name,
            scenario_definition.get("method", ""),
            scenario_definition.get("stab-url", ""),
            scenario_definition.get("tps", 0),
            0,
            scenario_definition.get("weight", 0),
            0
        ])

def find_conf_files_pathlib(key_filepath, csv_output="output.csv", replace_with_placeholder=False):
    """Creates a CSV file with extracted TPS values from config files."""
    with open(csv_output, mode="w", newline="") as file:
        csv_writer = csv.writer(file)
        csv_writer.writerow(["API Name", "File Name", "Scenario", "Method", "Stab-URL", "Default TPS", "Prod TPS", "Prod Weight", "Delta TPS", "Delta Weight"])
        
        p = Path(key_filepath)
        for conf_file in p.rglob("*.conf"):
            if "scenarios" in conf_file.name:
                conf = ConfigParser()
                conf.read(conf_file)
                definitions = conf.get("test_definitions", {})
                process_definitions(definitions, conf_file, csv_writer)
                
                if replace_with_placeholder:
                    replace_values_with_placeholders(conf_file, definitions)

if __name__ == "__main__":
    directory_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "api-gatling-tests-java/src/main/resources/api"))
    find_conf_files_pathlib(directory_path, csv_output="scenario_config.csv", replace_with_placeholder=True)










-----

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.StreamSupport;

public class DynamicConfigBuilder {
    
    protected Map<String, Object> buildDynamicConfig(String csvPath) throws IOException {
        Map<String, Object> rootMap = new HashMap<>();
        Map<String, Object> scenariosMap = readScenariosFromCsv(csvPath);
        Map<String, Object> testMap = new HashMap<>();
        
        testMap.put("definitions", scenariosMap);
        rootMap.put("test", testMap);
        
        return rootMap;
    }

    private Map<String, Object> readScenariosFromCsv(String csvPath) throws IOException {
        Map<String, Object> scenariosMap = new HashMap<>();
        
        try (BufferedReader br = Files.newBufferedReader(Path.of(csvPath))) {
            String headerLine = br.readLine();
            if (headerLine == null) {
                throw new IllegalArgumentException("CSV file is empty");
            }
            String[] headers = headerLine.split(",");
            Map<String, Integer> headerIndexMap = new HashMap<>();
            for (int i = 0; i < headers.length; i++) {
                headerIndexMap.put(headers[i].trim().toLowerCase(), i);
            }

            String line;
            while ((line = br.readLine()) != null) {
                String[] values = line.split(",");
                String scenarioName = getCellValue(values, headerIndexMap, "scenario");
                assert scenarioName != null && !scenarioName.isEmpty() : 
                    "Scenario name is null or empty in row " + line;

                double defaultTps = Double.parseDouble(getCellValue(values, headerIndexMap, "default tps"));
                double prodTps = Double.parseDouble(getCellValue(values, headerIndexMap, "prod tps"));
                double prodWeight = Double.parseDouble(getCellValue(values, headerIndexMap, "prod weight"));
                double deltaTps = Double.parseDouble(getCellValue(values, headerIndexMap, "delta tps"));
                double deltaWeight = Double.parseDouble(getCellValue(values, headerIndexMap, "delta weight"));

                var tpsData = new TPSData(defaultTps, prodTps, prodWeight, deltaTps, deltaWeight);
                double finalTps = MaxTpsCalculator.calculateFinalTps(tpsData);

                var valueMap = Map.of("tps", finalTps);
                scenariosMap.put(scenarioName, valueMap);
            }
        }
        
        return scenariosMap;
    }

    private String getCellValue(String[] values, Map<String, Integer> headerIndexMap, String headerName) {
        Integer columnIndex = headerIndexMap.get(headerName.toLowerCase());
        if (columnIndex == null || columnIndex >= values.length) {
            throw new IllegalArgumentException("Header not found or index out of bounds: " + headerName);
        }
        return values[columnIndex].trim();
    }
}
